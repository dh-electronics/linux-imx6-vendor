/*
 * Copyright 2015 DH electronics GmbH
 *
 * The code contained herein is licensed under the GNU General Public
 * License. You may obtain a copy of the GNU General Public License
 * Version 2 or later at the following locations:
 *
 * http://www.opensource.org/licenses/gpl-license.html
 * http://www.gnu.org/copyleft/gpl.html
 */

#include <dt-bindings/pwm/pwm.h>
#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/clock/imx6qdl-clock.h>

/ {
	clocks {
		#address-cells = <1>;
		#size-cells = <0>;
		clk_ext_spi2can: clock@1 {
			compatible = "fixed-clock";
			reg = <1>;
			#clock-cells = <0>;
			clock-frequency = <24000000>;
		};
	};
};

&ecspi1 {									// ********** SPI 1 **********
	spidev@2 {								// ==> /dev/spidev0.2
		compatible =  "spidev", "fsl,ecspi";
		reg = <2>;							// SS2
		spi-max-frequency = <54000000>;
		spi-cpha;							// Shifted clock phase (CPHA) mode
		spi-cpol;							// Inverse clock polarity (CPOL) mode
	};
};

&ecspi2 {									// ********** SPI 2 **********
	can@0 {
		compatible = "microchip,mcp2515";
		reg = <0>;							// SS0
		clocks = <&clk_ext_spi2can>;
		interrupt-parent = <&gpio4>;					// Use INT_HIGHEST_PRIORITY GPIO 4.6 for interrupt
		interrupts = <6 0x2>;
		spi-max-frequency = <3000000>;					// MCP2515 limit is 10MHz, because of the voltage divider in MISO we use 3MHz
		spi-cpha;							// Shifted clock phase (CPHA) mode
		spi-cpol;							// Inverse clock polarity (CPOL) mode
	};
};

&DHCOM_I2C1 {									// ********** I2C 1 **********
};

&DHCOM_I2C2 {									// ********** I2C 2 **********
};

&DHCOM_I2C_ONMODULE {								// ****** I2C onModule *******
};

&uart5 { 									// UART 2 (BT) ==> /dev/ttymxc4
	fsl,rs485-mode;								// Enable rs485 mode
	rts_gpio = <&gpio7 13 0>;						// GPIO P: rs485 rts = Receive Transmit Switch GPIO
	rxen_gpio = <&gpio1 18 0>;						// GPIO Q: rs485 rxen = RX Enable GPIO
	//rs485-rx-during-tx;							// Receive data during transfer
	status = "okay";
};

&iomuxc {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_dhcom_hog_base &pinctrl_dhcom_hog>;

	imx6qdl-drc01_base {
		pinctrl_dhcom_hog: hog_grp {
			fsl,pins = <
				MX6QDL_PAD_GPIO_2__GPIO1_IO02       0x400120B0	// GPIO A
				MX6QDL_PAD_GPIO_4__GPIO1_IO04       0x400120B0	// GPIO B
				MX6QDL_PAD_GPIO_5__GPIO1_IO05       0x400120B0	// GPIO C
				MX6QDL_PAD_CSI0_DAT17__GPIO6_IO03   0x400120B0	// GPIO D
				MX6QDL_PAD_GPIO_19__GPIO4_IO05      0x400120B0	// GPIO E
				MX6QDL_PAD_DI0_PIN4__GPIO4_IO20     0x400120B0	// GPIO F
				MX6QDL_PAD_EIM_D27__GPIO3_IO27      0x400120B0	// GPIO G
				MX6QDL_PAD_KEY_ROW0__GPIO4_IO07     0x400120B0	// GPIO H
				MX6QDL_PAD_KEY_COL1__GPIO4_IO08     0x400120B0	// GPIO I
				MX6QDL_PAD_NANDF_CS1__GPIO6_IO14    0x400120B0	// GPIO J
				MX6QDL_PAD_NANDF_CS2__GPIO6_IO15    0x400120B0	// GPIO K
				MX6QDL_PAD_KEY_ROW1__GPIO4_IO09     0x400120B0	// GPIO L
				MX6QDL_PAD_SD3_DAT5__GPIO7_IO00     0x400120B0	// GPIO M
				MX6QDL_PAD_SD3_DAT4__GPIO7_IO01     0x400120B0	// GPIO N
				MX6QDL_PAD_CSI0_VSYNC__GPIO5_IO21   0x400120B0	// GPIO O
				MX6QDL_PAD_GPIO_18__GPIO7_IO13      0x400120B0	// GPIO P -> rs485 rts
				MX6QDL_PAD_SD1_CMD__GPIO1_IO18      0x400120B0	// GPIO Q -> rs485 rxen
				MX6QDL_PAD_SD1_DAT0__GPIO1_IO16     0x400120B0	// GPIO R
				MX6QDL_PAD_SD1_DAT1__GPIO1_IO17     0x400120B0	// GPIO S
				MX6QDL_PAD_SD1_DAT2__GPIO1_IO19     0x400120B0	// GPIO T
				MX6QDL_PAD_SD1_CLK__GPIO1_IO20      0x400120B0	// GPIO U
				MX6QDL_PAD_CSI0_PIXCLK__GPIO5_IO18  0x400120B0	// GPIO V
				MX6QDL_PAD_CSI0_MCLK__GPIO5_IO19    0x400120B0	// GPIO W
				MX6QDL_PAD_KEY_COL0__GPIO4_IO06     0x400120B0	// INT_HIGHEST_PRIORITY -> spi2can
			>;
		};
	};
};
